{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useCallback, useRef, useState } from 'react';\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\nimport { getContainingBlock } from '../internal/utils/dom';\nimport { calculateScroll, getFirstScrollableParent, scrollRectangleIntoView } from '../internal/utils/scrollable-containers';\nimport { calculatePosition, getDimensions, getOffsetDimensions } from './utils/positions';\nexport default function usePopoverPosition(_ref) {\n  let {\n    popoverRef,\n    bodyRef,\n    arrowRef,\n    trackRef,\n    contentRef,\n    allowScrollToFit,\n    allowVerticalOverflow,\n    preferredPosition,\n    renderWithPortal,\n    keepPosition\n  } = _ref;\n  const previousInternalPositionRef = useRef(null);\n  const [popoverStyle, setPopoverStyle] = useState({});\n  const [internalPosition, setInternalPosition] = useState(null);\n  // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n  const positionHandlerRef = useRef(() => {});\n  const updatePositionHandler = useCallback(function () {\n    let onContentResize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var _a;\n    if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {\n      return;\n    }\n    // Get important elements\n    const popover = popoverRef.current;\n    const body = bodyRef.current;\n    const arrow = arrowRef.current;\n    const document = popover.ownerDocument;\n    const track = trackRef.current;\n    // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n    // or track does not belong to the document - bail on calculating dimensions.\n    const {\n      offsetWidth,\n      offsetHeight\n    } = getOffsetDimensions(popover);\n    if (offsetWidth === 0 || offsetHeight === 0 || !nodeContains(document.body, track)) {\n      return;\n    }\n    // Imperatively move body off-screen to give it room to expand.\n    // Not doing this in React because this recalculation should happen\n    // in the span of a single frame without rerendering anything.\n    const prevInsetBlockStart = popover.style.insetBlockStart;\n    const prevInsetInlineStart = popover.style.insetInlineStart;\n    popover.style.insetBlockStart = '0';\n    popover.style.insetInlineStart = '0';\n    // Imperatively remove body styles that can remain from the previous computation.\n    body.style.maxBlockSize = '';\n    body.style.overflowX = '';\n    body.style.overflowY = '';\n    // Get rects representing key elements\n    // Use getComputedStyle for arrowRect to avoid modifications made by transform\n    const viewportRect = getViewportRect(document.defaultView);\n    const trackRect = getLogicalBoundingClientRect(track);\n    const arrowRect = getDimensions(arrow);\n    const containingBlock = getContainingBlock(popover);\n    const containingBlockRect = containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect;\n    const bodyBorderWidth = getBorderWidth(body);\n    const contentRect = getLogicalBoundingClientRect(contentRef.current);\n    const contentBoundingBox = {\n      inlineSize: contentRect.inlineSize + 2 * bodyBorderWidth,\n      blockSize: contentRect.blockSize + 2 * bodyBorderWidth\n    };\n    // When keepPosition is true and the recalculation was triggered by a resize of the popover content,\n    // we maintain the previously defined internal position,\n    // but we still call calculatePosition to know if the popover should be scrollable.\n    const shouldKeepPosition = keepPosition && onContentResize && !!previousInternalPositionRef.current;\n    const fixedInternalPosition = (_a = shouldKeepPosition && previousInternalPositionRef.current) !== null && _a !== void 0 ? _a : undefined;\n    // Calculate the arrow direction and viewport-relative position of the popover.\n    const {\n      scrollable,\n      internalPosition: newInternalPosition,\n      rect\n    } = calculatePosition({\n      preferredPosition,\n      fixedInternalPosition,\n      trigger: trackRect,\n      arrow: arrowRect,\n      body: contentBoundingBox,\n      container: containingBlock ? containingBlockRect : getDocumentRect(document),\n      viewport: viewportRect,\n      renderWithPortal,\n      allowVerticalOverflow\n    });\n    // Get the position of the popover relative to the offset parent.\n    const popoverOffset = toRelativePosition(rect, containingBlockRect);\n    // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n    // and use that to recalculate the new popover position.\n    const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));\n    // Bring back the container to its original position to prevent any flashing.\n    popover.style.insetBlockStart = prevInsetBlockStart;\n    popover.style.insetInlineStart = prevInsetInlineStart;\n    // Allow popover body to scroll if can't fit the popover into the container/viewport otherwise.\n    if (scrollable) {\n      body.style.maxBlockSize = rect.blockSize + 'px';\n      body.style.overflowX = 'hidden';\n      body.style.overflowY = 'auto';\n    }\n    // Remember the internal position in case we want to keep it later.\n    previousInternalPositionRef.current = newInternalPosition;\n    setInternalPosition(newInternalPosition);\n    const shouldScroll = allowScrollToFit && !shouldKeepPosition;\n    // Position the popover\n    const insetBlockStart = shouldScroll ? popoverOffset.insetBlockStart + calculateScroll(rect) : popoverOffset.insetBlockStart;\n    setPopoverStyle({\n      insetBlockStart,\n      insetInlineStart: popoverOffset.insetInlineStart\n    });\n    // Scroll if necessary\n    if (shouldScroll) {\n      const scrollableParent = getFirstScrollableParent(popover);\n      scrollRectangleIntoView(rect, scrollableParent);\n    }\n    positionHandlerRef.current = () => {\n      const newTrackOffset = toRelativePosition(getLogicalBoundingClientRect(track), containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect);\n      setPopoverStyle({\n        insetBlockStart: newTrackOffset.insetBlockStart + trackRelativeOffset.insetBlockStart,\n        insetInlineStart: newTrackOffset.insetInlineStart + trackRelativeOffset.insetInlineStart\n      });\n    };\n  }, [trackRef, popoverRef, bodyRef, contentRef, arrowRef, keepPosition, allowScrollToFit, preferredPosition, renderWithPortal, allowVerticalOverflow]);\n  return {\n    updatePositionHandler,\n    popoverStyle,\n    internalPosition,\n    positionHandlerRef\n  };\n}\nfunction getBorderWidth(element) {\n  return parseInt(getComputedStyle(element).borderWidth) || 0;\n}\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\nfunction toRelativePosition(element, parent) {\n  return {\n    insetBlockStart: element.insetBlockStart - parent.insetBlockStart,\n    insetInlineStart: element.insetInlineStart - parent.insetInlineStart\n  };\n}\n/**\n * Get a BoundingBox that represents the visible viewport.\n */\nfunction getViewportRect(window) {\n  var _a, _b, _c, _d;\n  return {\n    insetBlockStart: 0,\n    insetInlineStart: 0,\n    inlineSize: (_b = (_a = window.visualViewport) === null || _a === void 0 ? void 0 : _a.width) !== null && _b !== void 0 ? _b : window.innerWidth,\n    blockSize: (_d = (_c = window.visualViewport) === null || _c === void 0 ? void 0 : _c.height) !== null && _d !== void 0 ? _d : window.innerHeight\n  };\n}\nfunction getDocumentRect(document) {\n  const {\n    insetBlockStart,\n    insetInlineStart\n  } = getLogicalBoundingClientRect(document.documentElement);\n  return {\n    insetBlockStart,\n    insetInlineStart,\n    inlineSize: document.documentElement.scrollWidth,\n    blockSize: document.documentElement.scrollHeight\n  };\n}","map":{"version":3,"names":["useCallback","useRef","useState","nodeContains","getLogicalBoundingClientRect","getContainingBlock","calculateScroll","getFirstScrollableParent","scrollRectangleIntoView","calculatePosition","getDimensions","getOffsetDimensions","usePopoverPosition","_ref","popoverRef","bodyRef","arrowRef","trackRef","contentRef","allowScrollToFit","allowVerticalOverflow","preferredPosition","renderWithPortal","keepPosition","previousInternalPositionRef","popoverStyle","setPopoverStyle","internalPosition","setInternalPosition","positionHandlerRef","updatePositionHandler","onContentResize","arguments","length","undefined","current","popover","body","arrow","document","ownerDocument","track","offsetWidth","offsetHeight","prevInsetBlockStart","style","insetBlockStart","prevInsetInlineStart","insetInlineStart","maxBlockSize","overflowX","overflowY","viewportRect","getViewportRect","defaultView","trackRect","arrowRect","containingBlock","containingBlockRect","bodyBorderWidth","getBorderWidth","contentRect","contentBoundingBox","inlineSize","blockSize","shouldKeepPosition","fixedInternalPosition","_a","scrollable","newInternalPosition","rect","trigger","container","getDocumentRect","viewport","popoverOffset","toRelativePosition","trackRelativeOffset","shouldScroll","scrollableParent","newTrackOffset","element","parseInt","getComputedStyle","borderWidth","parent","window","_b","visualViewport","width","innerWidth","_d","_c","height","innerHeight","documentElement","scrollWidth","scrollHeight"],"sources":["/home/jj/aws-threat-model-app/node_modules/src/popover/use-popover-position.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport React, { useCallback, useRef, useState } from 'react';\n\nimport { nodeContains } from '@cloudscape-design/component-toolkit/dom';\nimport { getLogicalBoundingClientRect } from '@cloudscape-design/component-toolkit/internal';\n\nimport { getContainingBlock } from '../internal/utils/dom';\nimport {\n  calculateScroll,\n  getFirstScrollableParent,\n  scrollRectangleIntoView,\n} from '../internal/utils/scrollable-containers';\nimport { BoundingBox, InternalPosition, Offset, PopoverProps } from './interfaces';\nimport { calculatePosition, getDimensions, getOffsetDimensions } from './utils/positions';\n\nexport default function usePopoverPosition({\n  popoverRef,\n  bodyRef,\n  arrowRef,\n  trackRef,\n  contentRef,\n  allowScrollToFit,\n  allowVerticalOverflow,\n  preferredPosition,\n  renderWithPortal,\n  keepPosition,\n}: {\n  popoverRef: React.RefObject<HTMLDivElement | null>;\n  bodyRef: React.RefObject<HTMLDivElement | null>;\n  arrowRef: React.RefObject<HTMLDivElement | null>;\n  trackRef: React.RefObject<HTMLElement | SVGElement | null>;\n  contentRef: React.RefObject<HTMLDivElement | null>;\n  allowScrollToFit?: boolean;\n  allowVerticalOverflow?: boolean;\n  preferredPosition: PopoverProps.Position;\n  renderWithPortal?: boolean;\n  keepPosition?: boolean;\n}) {\n  const previousInternalPositionRef = useRef<InternalPosition | null>(null);\n  const [popoverStyle, setPopoverStyle] = useState<Partial<Offset>>({});\n  const [internalPosition, setInternalPosition] = useState<InternalPosition | null>(null);\n\n  // Store the handler in a ref so that it can still be replaced from outside of the listener closure.\n  const positionHandlerRef = useRef<() => void>(() => {});\n\n  const updatePositionHandler = useCallback(\n    (onContentResize = false) => {\n      if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {\n        return;\n      }\n\n      // Get important elements\n      const popover = popoverRef.current;\n      const body = bodyRef.current;\n      const arrow = arrowRef.current;\n      const document = popover.ownerDocument;\n      const track = trackRef.current;\n\n      // If the popover body isn't being rendered for whatever reason (e.g. \"display: none\" or JSDOM),\n      // or track does not belong to the document - bail on calculating dimensions.\n      const { offsetWidth, offsetHeight } = getOffsetDimensions(popover);\n      if (offsetWidth === 0 || offsetHeight === 0 || !nodeContains(document.body, track)) {\n        return;\n      }\n\n      // Imperatively move body off-screen to give it room to expand.\n      // Not doing this in React because this recalculation should happen\n      // in the span of a single frame without rerendering anything.\n      const prevInsetBlockStart = popover.style.insetBlockStart;\n      const prevInsetInlineStart = popover.style.insetInlineStart;\n\n      popover.style.insetBlockStart = '0';\n      popover.style.insetInlineStart = '0';\n      // Imperatively remove body styles that can remain from the previous computation.\n      body.style.maxBlockSize = '';\n      body.style.overflowX = '';\n      body.style.overflowY = '';\n\n      // Get rects representing key elements\n      // Use getComputedStyle for arrowRect to avoid modifications made by transform\n      const viewportRect = getViewportRect(document.defaultView!);\n      const trackRect = getLogicalBoundingClientRect(track);\n      const arrowRect = getDimensions(arrow);\n      const containingBlock = getContainingBlock(popover);\n      const containingBlockRect = containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect;\n\n      const bodyBorderWidth = getBorderWidth(body);\n      const contentRect = getLogicalBoundingClientRect(contentRef.current);\n      const contentBoundingBox = {\n        inlineSize: contentRect.inlineSize + 2 * bodyBorderWidth,\n        blockSize: contentRect.blockSize + 2 * bodyBorderWidth,\n      };\n\n      // When keepPosition is true and the recalculation was triggered by a resize of the popover content,\n      // we maintain the previously defined internal position,\n      // but we still call calculatePosition to know if the popover should be scrollable.\n      const shouldKeepPosition = keepPosition && onContentResize && !!previousInternalPositionRef.current;\n      const fixedInternalPosition = (shouldKeepPosition && previousInternalPositionRef.current) ?? undefined;\n\n      // Calculate the arrow direction and viewport-relative position of the popover.\n      const {\n        scrollable,\n        internalPosition: newInternalPosition,\n        rect,\n      } = calculatePosition({\n        preferredPosition,\n        fixedInternalPosition,\n        trigger: trackRect,\n        arrow: arrowRect,\n        body: contentBoundingBox,\n        container: containingBlock ? containingBlockRect : getDocumentRect(document),\n        viewport: viewportRect,\n        renderWithPortal,\n        allowVerticalOverflow,\n      });\n\n      // Get the position of the popover relative to the offset parent.\n      const popoverOffset = toRelativePosition(rect, containingBlockRect);\n\n      // Cache the distance between the trigger and the popover (which stays the same as you scroll),\n      // and use that to recalculate the new popover position.\n      const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));\n\n      // Bring back the container to its original position to prevent any flashing.\n      popover.style.insetBlockStart = prevInsetBlockStart;\n      popover.style.insetInlineStart = prevInsetInlineStart;\n\n      // Allow popover body to scroll if can't fit the popover into the container/viewport otherwise.\n      if (scrollable) {\n        body.style.maxBlockSize = rect.blockSize + 'px';\n        body.style.overflowX = 'hidden';\n        body.style.overflowY = 'auto';\n      }\n\n      // Remember the internal position in case we want to keep it later.\n      previousInternalPositionRef.current = newInternalPosition;\n      setInternalPosition(newInternalPosition);\n\n      const shouldScroll = allowScrollToFit && !shouldKeepPosition;\n\n      // Position the popover\n      const insetBlockStart = shouldScroll\n        ? popoverOffset.insetBlockStart + calculateScroll(rect)\n        : popoverOffset.insetBlockStart;\n      setPopoverStyle({ insetBlockStart, insetInlineStart: popoverOffset.insetInlineStart });\n\n      // Scroll if necessary\n      if (shouldScroll) {\n        const scrollableParent = getFirstScrollableParent(popover);\n        scrollRectangleIntoView(rect, scrollableParent);\n      }\n\n      positionHandlerRef.current = () => {\n        const newTrackOffset = toRelativePosition(\n          getLogicalBoundingClientRect(track),\n          containingBlock ? getLogicalBoundingClientRect(containingBlock) : viewportRect\n        );\n        setPopoverStyle({\n          insetBlockStart: newTrackOffset.insetBlockStart + trackRelativeOffset.insetBlockStart,\n          insetInlineStart: newTrackOffset.insetInlineStart + trackRelativeOffset.insetInlineStart,\n        });\n      };\n    },\n    [\n      trackRef,\n      popoverRef,\n      bodyRef,\n      contentRef,\n      arrowRef,\n      keepPosition,\n      allowScrollToFit,\n      preferredPosition,\n      renderWithPortal,\n      allowVerticalOverflow,\n    ]\n  );\n  return { updatePositionHandler, popoverStyle, internalPosition, positionHandlerRef };\n}\n\nfunction getBorderWidth(element: HTMLElement) {\n  return parseInt(getComputedStyle(element).borderWidth) || 0;\n}\n\n/**\n * Convert a viewport-relative offset to an element-relative offset.\n */\nfunction toRelativePosition(element: Offset, parent: Offset): Offset {\n  return {\n    insetBlockStart: element.insetBlockStart - parent.insetBlockStart,\n    insetInlineStart: element.insetInlineStart - parent.insetInlineStart,\n  };\n}\n\n/**\n * Get a BoundingBox that represents the visible viewport.\n */\nfunction getViewportRect(window: Window): BoundingBox {\n  return {\n    insetBlockStart: 0,\n    insetInlineStart: 0,\n    inlineSize: window.visualViewport?.width ?? window.innerWidth,\n    blockSize: window.visualViewport?.height ?? window.innerHeight,\n  };\n}\n\nfunction getDocumentRect(document: Document): BoundingBox {\n  const { insetBlockStart, insetInlineStart } = getLogicalBoundingClientRect(document.documentElement);\n\n  return {\n    insetBlockStart,\n    insetInlineStart,\n    inlineSize: document.documentElement.scrollWidth,\n    blockSize: document.documentElement.scrollHeight,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}