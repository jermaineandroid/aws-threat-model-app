import { __rest } from "tslib";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useImperativeHandle, useState } from 'react';
import ScreenreaderOnly from '../../internal/components/screenreader-only';
import { fireNonCancelableEvent } from '../../internal/events';
import { useControllable } from '../../internal/hooks/use-controllable';
import { useMobile } from '../../internal/hooks/use-mobile';
import { useUniqueId } from '../../internal/hooks/use-unique-id';
import { useGetGlobalBreadcrumbs } from '../../internal/plugins/helpers/use-global-breadcrumbs';
import globalVars from '../../internal/styles/global-vars';
import { getSplitPanelDefaultSize } from '../../split-panel/utils/size-utils';
import { useDrawers } from '../utils/use-drawers';
import { useFocusControl } from '../utils/use-focus-control';
import { useSplitPanelFocusControl } from '../utils/use-split-panel-focus-control';
import { computeHorizontalLayout, computeVerticalLayout } from './compute-layout';
import { AppLayoutDrawer, AppLayoutNavigation, AppLayoutNotifications, AppLayoutSplitPanelBottom, AppLayoutSplitPanelSide, AppLayoutToolbar, } from './internal';
import { useMultiAppLayout } from './multi-layout';
import { SkeletonLayout } from './skeleton';
const AppLayoutVisualRefreshToolbar = React.forwardRef((_a, forwardRef) => {
    var _b, _c;
    var { ariaLabels, contentHeader, content, navigationOpen, navigationWidth, navigation, navigationHide, onNavigationChange, tools, toolsOpen: controlledToolsOpen, onToolsChange, toolsHide, toolsWidth, contentType, headerVariant, breadcrumbs, notifications, stickyNotifications, splitPanelPreferences: controlledSplitPanelPreferences, splitPanelOpen: controlledSplitPanelOpen, splitPanel, splitPanelSize: controlledSplitPanelSize, onSplitPanelToggle, onSplitPanelResize, onSplitPanelPreferencesChange, disableContentPaddings, minContentWidth, maxContentWidth, placement } = _a, rest = __rest(_a, ["ariaLabels", "contentHeader", "content", "navigationOpen", "navigationWidth", "navigation", "navigationHide", "onNavigationChange", "tools", "toolsOpen", "onToolsChange", "toolsHide", "toolsWidth", "contentType", "headerVariant", "breadcrumbs", "notifications", "stickyNotifications", "splitPanelPreferences", "splitPanelOpen", "splitPanel", "splitPanelSize", "onSplitPanelToggle", "onSplitPanelResize", "onSplitPanelPreferencesChange", "disableContentPaddings", "minContentWidth", "maxContentWidth", "placement"]);
    const isMobile = useMobile();
    const { __embeddedViewMode: embeddedViewMode, __forceDeduplicationType: forceDeduplicationType } = rest;
    const splitPanelControlId = useUniqueId('split-panel');
    const [toolbarState, setToolbarState] = useState('show');
    const [toolbarHeight, setToolbarHeight] = useState(0);
    const [notificationsHeight, setNotificationsHeight] = useState(0);
    const onNavigationToggle = (open) => {
        fireNonCancelableEvent(onNavigationChange, { open });
    };
    const [toolsOpen = false, setToolsOpen] = useControllable(controlledToolsOpen, onToolsChange, false, {
        componentName: 'AppLayout',
        controlledProp: 'toolsOpen',
        changeHandler: 'onToolsChange',
    });
    const onToolsToggle = (open) => {
        setToolsOpen(open);
        drawersFocusControl.setFocus();
        fireNonCancelableEvent(onToolsChange, { open });
    };
    const { drawers, activeDrawer, minDrawerSize, activeDrawerSize, ariaLabelsWithDrawers, onActiveDrawerChange, onActiveDrawerResize, } = useDrawers(rest, ariaLabels, {
        ariaLabels,
        toolsHide,
        toolsOpen,
        tools,
        toolsWidth,
        onToolsToggle,
    });
    const onActiveDrawerChangeHandler = (drawerId) => {
        onActiveDrawerChange(drawerId);
        drawersFocusControl.setFocus();
    };
    const [splitPanelOpen = false, setSplitPanelOpen] = useControllable(controlledSplitPanelOpen, onSplitPanelToggle, false, {
        componentName: 'AppLayout',
        controlledProp: 'splitPanelOpen',
        changeHandler: 'onSplitPanelToggle',
    });
    const onSplitPanelToggleHandler = () => {
        setSplitPanelOpen(!splitPanelOpen);
        fireNonCancelableEvent(onSplitPanelToggle, { open: !splitPanelOpen });
    };
    const [splitPanelPreferences, setSplitPanelPreferences] = useControllable(controlledSplitPanelPreferences, onSplitPanelPreferencesChange, undefined, {
        componentName: 'AppLayout',
        controlledProp: 'splitPanelPreferences',
        changeHandler: 'onSplitPanelPreferencesChange',
    });
    const onSplitPanelPreferencesChangeHandler = (detail) => {
        setSplitPanelPreferences(detail);
        splitPanelFocusControl.setLastInteraction({ type: 'position' });
        fireNonCancelableEvent(onSplitPanelPreferencesChange, detail);
    };
    const [splitPanelSize = 0, setSplitPanelSize] = useControllable(controlledSplitPanelSize, onSplitPanelResize, getSplitPanelDefaultSize((_b = splitPanelPreferences === null || splitPanelPreferences === void 0 ? void 0 : splitPanelPreferences.position) !== null && _b !== void 0 ? _b : 'bottom'), { componentName: 'AppLayout', controlledProp: 'splitPanelSize', changeHandler: 'onSplitPanelResize' });
    const [splitPanelReportedSize, setSplitPanelReportedSize] = useState(0);
    const onSplitPanelResizeHandler = (size) => {
        setSplitPanelSize(size);
        fireNonCancelableEvent(onSplitPanelResize, { size });
    };
    const [splitPanelToggleConfig, setSplitPanelToggleConfig] = useState({
        ariaLabel: undefined,
        displayed: false,
    });
    const drawersFocusControl = useFocusControl(!!(activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.id), !isMobile, activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.id);
    const navigationFocusControl = useFocusControl(navigationOpen);
    const splitPanelFocusControl = useSplitPanelFocusControl([splitPanelPreferences, splitPanelOpen]);
    useImperativeHandle(forwardRef, () => ({
        closeNavigationIfNecessary: () => isMobile && onNavigationToggle(false),
        openTools: () => onToolsToggle(true),
        focusToolsClose: () => drawersFocusControl.setFocus(true),
        focusActiveDrawer: () => drawersFocusControl.setFocus(true),
        focusSplitPanel: () => { var _a; return (_a = splitPanelFocusControl.refs.slider.current) === null || _a === void 0 ? void 0 : _a.focus(); },
    }));
    const resolvedNavigation = navigationHide ? null : navigation !== null && navigation !== void 0 ? navigation : React.createElement(React.Fragment, null);
    const { maxDrawerSize, maxSplitPanelSize, splitPanelForcedPosition, splitPanelPosition } = computeHorizontalLayout({
        activeDrawerSize: activeDrawer ? activeDrawerSize : 0,
        splitPanelSize,
        minContentWidth,
        navigationOpen: !!resolvedNavigation && navigationOpen,
        navigationWidth,
        placement,
        splitPanelOpen,
        splitPanelPosition: splitPanelPreferences === null || splitPanelPreferences === void 0 ? void 0 : splitPanelPreferences.position,
        isMobile,
    });
    const { registered, toolbarProps } = useMultiAppLayout({
        forceDeduplicationType,
        ariaLabels: ariaLabelsWithDrawers,
        navigation: resolvedNavigation,
        navigationOpen,
        onNavigationToggle,
        navigationFocusRef: navigationFocusControl.refs.toggle,
        breadcrumbs,
        activeDrawerId: (_c = activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.id) !== null && _c !== void 0 ? _c : null,
        // only pass it down if there are non-empty drawers or tools
        drawers: (drawers === null || drawers === void 0 ? void 0 : drawers.length) || !toolsHide ? drawers : undefined,
        onActiveDrawerChange: onActiveDrawerChangeHandler,
        drawersFocusRef: drawersFocusControl.refs.toggle,
        splitPanel,
        splitPanelToggleProps: Object.assign(Object.assign({}, splitPanelToggleConfig), { active: splitPanelOpen, controlId: splitPanelControlId, position: splitPanelPosition }),
        splitPanelFocusRef: splitPanelFocusControl.refs.toggle,
        onSplitPanelToggle: onSplitPanelToggleHandler,
    });
    const hasToolbar = !embeddedViewMode && !!toolbarProps;
    const discoveredBreadcrumbs = useGetGlobalBreadcrumbs(hasToolbar);
    const verticalOffsets = computeVerticalLayout({
        topOffset: placement.insetBlockStart,
        hasVisibleToolbar: hasToolbar && toolbarState !== 'hide' && !isMobile,
        notificationsHeight: notificationsHeight !== null && notificationsHeight !== void 0 ? notificationsHeight : 0,
        toolbarHeight: toolbarHeight !== null && toolbarHeight !== void 0 ? toolbarHeight : 0,
        stickyNotifications: !!stickyNotifications,
    });
    const appLayoutInternals = {
        ariaLabels: ariaLabelsWithDrawers,
        headerVariant,
        isMobile,
        breadcrumbs,
        discoveredBreadcrumbs,
        stickyNotifications,
        navigationOpen,
        navigation: resolvedNavigation,
        navigationFocusControl,
        activeDrawer,
        activeDrawerSize,
        minDrawerSize,
        maxDrawerSize,
        drawers: drawers,
        drawersFocusControl,
        splitPanelPosition,
        splitPanelToggleConfig,
        splitPanelOpen,
        splitPanelControlId,
        splitPanelFocusControl,
        placement,
        toolbarState,
        setToolbarState,
        verticalOffsets,
        setToolbarHeight,
        setNotificationsHeight,
        onSplitPanelToggle: onSplitPanelToggleHandler,
        onNavigationToggle,
        onActiveDrawerChange: onActiveDrawerChangeHandler,
        onActiveDrawerResize,
    };
    const splitPanelInternals = {
        bottomOffset: 0,
        getMaxHeight: () => {
            const availableHeight = document.documentElement.clientHeight - placement.insetBlockStart - placement.insetBlockEnd;
            // If the page is likely zoomed in at 200%, allow the split panel to fill the content area.
            return availableHeight < 400 ? availableHeight - 40 : availableHeight - 250;
        },
        maxWidth: maxSplitPanelSize,
        isForcedPosition: splitPanelForcedPosition,
        isOpen: splitPanelOpen,
        leftOffset: 0,
        onPreferencesChange: onSplitPanelPreferencesChangeHandler,
        onResize: onSplitPanelResizeHandler,
        onToggle: onSplitPanelToggleHandler,
        position: splitPanelPosition,
        reportSize: size => setSplitPanelReportedSize(size),
        reportHeaderHeight: () => {
            /*unused in this design*/
        },
        rightOffset: 0,
        size: splitPanelSize,
        topOffset: 0,
        setSplitPanelToggle: setSplitPanelToggleConfig,
        refs: splitPanelFocusControl.refs,
    };
    return (React.createElement(React.Fragment, null,
        !hasToolbar && breadcrumbs ? React.createElement(ScreenreaderOnly, null, breadcrumbs) : null,
        React.createElement(SkeletonLayout, { style: {
                [globalVars.stickyVerticalTopOffset]: `${verticalOffsets.header}px`,
                [globalVars.stickyVerticalBottomOffset]: `${placement.insetBlockEnd}px`,
                paddingBlockEnd: splitPanelOpen && splitPanelPosition === 'bottom' ? splitPanelReportedSize : '',
            }, toolbar: hasToolbar && React.createElement(AppLayoutToolbar, { appLayoutInternals: appLayoutInternals, toolbarProps: toolbarProps }), notifications: notifications && (React.createElement(AppLayoutNotifications, { appLayoutInternals: appLayoutInternals }, notifications)), contentHeader: contentHeader, 
            // delay rendering the content until registration of this instance is complete
            content: registered ? content : null, navigation: resolvedNavigation && React.createElement(AppLayoutNavigation, { appLayoutInternals: appLayoutInternals }), navigationOpen: navigationOpen, navigationWidth: navigationWidth, tools: activeDrawer && React.createElement(AppLayoutDrawer, { appLayoutInternals: appLayoutInternals }), toolsOpen: !!activeDrawer, toolsWidth: activeDrawerSize, sideSplitPanel: splitPanelPosition === 'side' && (React.createElement(AppLayoutSplitPanelSide, { appLayoutInternals: appLayoutInternals, splitPanelInternals: splitPanelInternals }, splitPanel)), bottomSplitPanel: splitPanelPosition === 'bottom' && (React.createElement(AppLayoutSplitPanelBottom, { appLayoutInternals: appLayoutInternals, splitPanelInternals: splitPanelInternals }, splitPanel)), splitPanelOpen: splitPanelOpen, placement: placement, contentType: contentType, maxContentWidth: maxContentWidth, disableContentPaddings: disableContentPaddings })));
});
export default AppLayoutVisualRefreshToolbar;
//# sourceMappingURL=index.js.map